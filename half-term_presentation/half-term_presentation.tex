\documentclass{beamer}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage[babel=true]{csquotes}
\usepackage{graphicx}
\usepackage[export]{adjustbox}
\usepackage{amsmath}
\usepackage{algorithm2e}
\usepackage{hyperref}
\usepackage{listings}
\usepackage[toc,page]{appendix}
\usepackage[backend=biber,style=alphabetic]{biblatex}


\graphicspath{ {../images/} }
\usetheme{Copenhagen}
\setbeamertemplate{page number in head/foot}[totalframenumber]


\title{Profile-guided optimization}
\subtitle{Speeding up LHCb software through compilation optimization}
\author{Oscar Buon}


\begin{document}

\begin{frame}
    \centering
    \begin{minipage}{0.2\textwidth}
        \includegraphics[width=\textwidth]{logo_ISIMA_INP.png}
    \end{minipage}\hfill
    \begin{minipage}{0.2\textwidth}
        \includegraphics[width=\textwidth]{logo_CERN.png}
    \end{minipage}\hfill
    \begin{minipage}{0.2\textwidth}
        \includegraphics[width=\textwidth]{logo_LHCb.png}
    \end{minipage}

    \maketitle

    Supervisor: Sebastien Ponce
\end{frame}

\part{Introduction}
\section*{Introduction}
\part{Body}

    \begin{frame}
        \frametitle{CERN}

        Intergovernmental particle physics on France-Switzerland border.

        About  15,000 people working at CERN.

        Made discoveries that led to Nobel Prizes.

        World Wide Web was invented at CERN.
    \end{frame}

    \begin{frame}
        \includegraphics[width=0.75\textwidth]{WEB.jpg}
    \end{frame}

    \begin{frame}
        \frametitle{Large Hadron Collider (LHC)}

        \begin{itemize}
            \item Large Hadron Collider: particle collider
            \item $ 27 km $ (biggest in the world)
            \item $ \sim 100 m $ underground
        \end{itemize}

        \includegraphics[width=0.5\textwidth]{LHC.jpg}
    \end{frame}

    \begin{frame}
        \frametitle{LHCb}

        \begin{itemize}
            \item One of the 4 main experiments installed on the LHC.
            \item More than 1,200 people working for the collaboration.
            \item Studies asymmetry between matter and antimatter via b-physics.
            Collision of hadrons (heavy particles).
        \end{itemize}

        \includegraphics[width=0.5\textwidth]{LHCb.jpg}
    \end{frame}

    \begin{frame}
        \frametitle{Physics Computing}

        The detector needs an important computing infrastructure to work properly.

        The detector produces about TB/s of data that are analyzed to reconstruct the trajectories and the properties of the particles.

        Then statistics are made from these reconstructed particles.
        Moreover simulations are made through the software.
        Then statistics are comapred to the simulations.

        Some computing analysis are dispatched in servers arround the world (grid).
    \end{frame}

    \begin{frame}
        \frametitle{Computing group}

        A first level software will filter data to keep interresting tracks.

        Then data are stored in a buffer for hours to be analyzed in a second level software.

        Some computing analysis are dispatched in servers arround the world (grid).

        The computing group has to maintain this infrastructure for LHCb.
    \end{frame}

    \begin{frame}
        \frametitle{Software}

        The software is a stack programms:

        \begin{itemize}
            \item The base of the stack is composed of software like ROOT or Gaudi that are shared with other experiments.
            \item On top of them there are Detector, LHCb or Lbcom that modelise the experiment.
            \item And then there are Rec that reconstruct the tracks and the simulation programms.
            \item Some other programms are to use or to test the others, like Moore.
        \end{itemize}

        There are several million lines of code which some are 30 years old.
        Moreover the code is mainly written by non-software engineers.

        All of this is running on thousands of multithreaded Linux servers.
    \end{frame}

    \begin{frame}
        \frametitle{Table of contents}
        \tableofcontents
    \end{frame}

\section{Graphviz for printing graphs}

    \begin{frame}[fragile]
        \frametitle{Graphviz for printing graphs}

        Printing graphs was usefull to have an idea of the dependencies.

        Graphviz in CMake to create dependency graphs:
        \begin{itemize}
            \item CMake arg: \verb'--graphviz=path/to/files.dot'
            \item Convert to SVG: \verb'dot -Tsvg -o path/to/file.svg path/to/file.dot'
            \item Make arg: \verb'CMAKEFLAGS="--graphviz=path/to/files.dot"'
            \item Setting \verb'GRAPHVIZ_EXTERNAL_LIBS' to \verb'FALSE' is usefull.
        \end{itemize}

    \end{frame}

    \begin{frame}
        \includegraphics[width=\textwidth]{graphviz.png}
    \end{frame}

\section{Static libraries and modules}

    \subsection{Context}

    \begin{frame}[fragile]
        \frametitle{Context}

        Worked on a stack with one main CMake:
        \scriptsize \url{https://gitlab.cern.ch/clemenci/lhcb-super-project-template/} \normalsize

        Target: \verb'x86_64_v3-centos7-gcc11+detdesc-opt+g'
    \end{frame}

    \subsection{Library types}

    \begin{frame}[fragile]
        \frametitle{Library types}

        \begin{itemize}
            \item STATIC: an archive of object files that are merged to the executable at link time.
            \item SHARED: .so (Linux) file that is automatically linked to the executable at runtime (when starting it).
            Allows several executables to link with a library installed on the system.
            \item MODULE: same as shared but the module is loaded on demand via the \verb'dlopen' function, so not automatically.
        \end{itemize}
    \end{frame}

    \subsection{Static libraries}

    \begin{frame}[fragile]
        \frametitle{Static libraries}

        Gaudi provides CMake functions to create libraries, modules or executables.
        Then we just have to create a new function for static libraries by copying the one for shared libraries:

        \verb'gaudi_add_library' $\Rightarrow$ \verb'gaudi_add_static_library'

        And inside remplacing \verb'SHARED' by \verb'STATIC' in \verb'add_library' function call.
    \end{frame}

    \subsection{Static modules}

    \begin{frame}[fragile]
        \frametitle{Static modules}

        By using previous static libraries.
        Need to add:
        \begin{itemize}
            \item \verb'-Wl,--whole-archive' link option while linking to the final executable.
            \item \verb'-Wl,--whole-archive' and \verb'-Wl,--allow-multiple-definition' link option to the executable.
            \item the global link option \verb'-Wl,--export-dynamic'
        \end{itemize}
    \end{frame}

    \begin{frame}[fragile]
        \frametitle{Explanation of flags}
        \begin{itemize}
            \item \verb'-Wl,--whole-archive' because without it the linker removes the code in the module that registers it.
            Note that this could be an error in the linker because that behavior was not the same when using object files instead of static libaries.
            \item \verb'-Wl,--allow-multiple-definition' because \verb'-Wl,--whole-archive' causes symbols to be included several times.
            \item \verb'-Wl,--export-dynamic' to allow functors to access to symbols.
        \end{itemize}

        We have to notice that some of these flags seem to be Hacks and are not recommended to be used.
        Moreover there may still be bugs, especially with functors.
    \end{frame}

    \begin{frame}[fragile]
        The final executable goes from $ \sim 20 kB $ to $ 2.5 GB $.

        The standard method to run test with python is not working. Need to run directly the executable with a json options file:
        \begin{lstlisting}[language=bash,basicstyle=\scriptsize,breaklines]
            build.x86_64_v3-centos7-gcc11+detdesc-opt+g/run ./build.x86_64_v3-centos7-gcc11+detdesc-opt+g/Gaudi/Gaudi/Gaudi_static options.json
        \end{lstlisting}
    \end{frame}

\section{Profile-guided optimization}

    \subsection{Profile-guided optimization}

    \begin{frame}
        \frametitle{Profile-guided optimization}

        The compiler uses some heuristics to optimize some elements:
        \begin{itemize}
            \item Inlining
            \item Block ordering
            \item Register allocation
            \item Virtual call speculation
            \item Dead code separation
        \end{itemize}
        But sometimes these heuristics are wrong.
    \end{frame}


    \begin{frame}
        A better way for the compiler should having running data.
        The the principle of PGO is:
        \begin{itemize}
            \item Compiling the programm with instrumentation.
            \item Running it to create profiles (counters).
            \item Recompiling the programm with the profiles.
        \end{itemize}
    \end{frame}
    \subsection{Link-time optimization}

    \begin{frame}
        \frametitle{Link-time optimization}

        Allows the linker to perform optimizations that take account of all translation units.
    \end{frame}

    \subsection{Final building pipeline}

    \begin{frame}[fragile]
        \frametitle{Final building pipeline}

        \begin{itemize}
            \item Compiling the programm with \verb'-fprofile-generate'
            \item Running it to create profiles
            \item Recompiling the programm with \verb'-flto -fprofile-use -fprofile-correction'
        \end{itemize}
    \end{frame}

\part{Conclusion}
\section*{Conclusion}

    \begin{frame}[fragile]
        \frametitle{Results}

        Test: \verb'hlt2_pp_thor' ($6 \times 1000$ events)
        \begin{center}
            \begin{tabular}{ c c c }
                Optimization & Acceleration & Confidence interval ($2\sigma$) \\
                LTO & $0.17\%$ & $\pm 1.12\%$ \\
                LTO \& PGO & $6.74\%$ & $\pm 1.44\%$ \\
                Static LTO & $0.87\%$ & $\pm 0.60\%$ \\
                Static LTO \& PGO & $6.88\%$ & $\pm 0.83\%$
            \end{tabular}
        \end{center}
    \end{frame}

    \begin{frame}
        \frametitle{Conclusion}

        \begin{itemize}
            \item Using LTO \& PGO makes the programm running faster.
            \item Using static libraries and modules doesn't seem to be usefull and leads to some bugs.
        \end{itemize}
    \end{frame}

\end{document}
